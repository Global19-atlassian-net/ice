package org.eclipse.ice.dev.annotations.processors;

import java.util.Collection;
import java.util.List;

import org.apache.commons.lang3.ClassUtils;
import org.apache.commons.lang3.StringUtils;

import com.fasterxml.jackson.annotation.JsonAlias;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;

import lombok.Builder;
import lombok.Data;
import lombok.NonNull;
import lombok.Singular;

/**
 * Container for Field information, taken from DataField Annotations, in
 * simplified form for use by Velocity template.
 *
 * @author Daniel Bluhm
 */
@Data
@Builder
@JsonDeserialize(builder = Field.FieldBuilder.class)
public class Field {
	/**
	 * Name of the field.
	 */
	String name;

	/**
	 * String representation of the field's type.
	 */
	String type;

	/**
	 * The default value of this field.
	 */
	String defaultValue;

	/**
	 * Comment to add to the field declaration.
	 */
	String docString;

	/**
	 * Whether or not this field can be null.
	 *
	 * This value affects the kind of checks generated in IDataElement.matches().
	 */
	boolean nullable;

	/**
	 * Whether or not the type of this field is a primitive type.
	 *
	 * This value affects the kind of checks generated in IDataElement.matches().
	 * This is inferred from the Field's type.
	 */
	boolean primitive;

	/**
	 * Whether or not this field should be included in IDataElement.matches().
	 */
	@Builder.Default boolean match = true;

	/**
	 * Generate a getter for this field.
	 */
	@Builder.Default boolean getter = true;

	/**
	 * Generate a setter for this field.
	 */
	@Builder.Default boolean setter = true;

	/**
	 * Whether this field is considered a "default" or included in all
	 * DataElements.
	 */
	boolean defaultField;

	/**
	 * Whether this field should be searchable with PersistenceHandler.
	 */
	@Builder.Default boolean search = true;

	/**
	 * A list of alternate names for this field.
	 */
	@Singular("alias") List<Field> aliases;

	/**
	 * Marker class used to mark a string value as one that should not be
	 * manipulated when building a field.
	 */
	@Data public static class Raw {
		@NonNull String value;
	}

	/**
	 * Convenience method for creating Raw value.
	 * @param value
	 * @return new Raw object
	 */
	public static Raw raw(String value) {
		return new Raw(value);
	}

	/**
	 * Get a class by name or return null if not found
	 * @param cls
	 * @return found class or null
	 */
	private static Class<?> getClassOrNull(String cls) {
		try {
			return ClassUtils.getClass(cls);
		} catch (ClassNotFoundException e) {
			return null;
		}
	}

	/**
	 * Return this Fields name ready for use in a method.
	 * @return capitalized name
	 */
	@JsonIgnore
	public String getNameForMethod() {
		return StringUtils.capitalize(this.name);
	}

	/**
	 * Reverse the escaping performed on defaultValues when the type of the field is
	 * a String. This is only used when serializing to JSON and will render a string
	 * the builder for this class will recognize.
	 * @return
	 */
	@JsonProperty("defaultValue")
	public String unescapeDefaultValue() {
		if (this.type == null) {
			return this.defaultValue;
		}
		Class<?> cls = getClassOrNull(this.type);
		if (this.defaultValue != null && cls != null && cls.equals(String.class)) {
			return this.defaultValue.substring(1, this.defaultValue.length() - 1);
		}
		return this.defaultValue;
	}

	/**
	 * Instruct Jackson how to deserialize aliases.
	 */
	private interface FieldBuilderMeta {
		@JsonDeserialize(contentAs = Field.class) FieldBuilder aliases(Collection<? extends Field> aliases);
	}

	/**
	 * Builder class for Field. This class must be a static inner class of Field in
	 * order to take advantage of Lombok's @Builder annotation. The methods defined
	 * here replace the defaults generated by Lombok and provide a multiple-dispatch
	 * based mechanism for customizing output based on the passed type.
	 *
	 * The methods prefixed with "json" are used for deserializing values from
	 * JSON using Jackson.
	 */
	@JsonPOJOBuilder(withPrefix = "json")
	public static class FieldBuilder implements FieldBuilderMeta {
		/**
		 * Store the Class of the field's type for use in determining whether the
		 * defaultValue should be escaped and whether the field is a primitive type.
		 */
		private Class<?> actualType;

		/**
		 * Whether the default value has already been formatted.
		 */
		private boolean defaultValueFormatted = false;

		private boolean shouldEscapeDefaultValue() {
			return
				this.defaultValue != null &&
				this.defaultValueFormatted == false &&
				this.actualType != null &&
				this.actualType.equals(String.class);
		}

		/**
		 * Format long as String for use as default value initializer.
		 * @param value the value to be formatted.
		 * @return FieldBuilder
		 */
		public FieldBuilder defaultValue(long value) {
			this.defaultValue = Long.toString(value) + "L";
			this.defaultValueFormatted = true;
			return this;
		}

		/**
		 * Format String as escaped String for use as default value initializer.
		 * @param value the value to be formatted.
		 * @return FieldBuilder
		 */
		public FieldBuilder defaultValue(String value) {
			this.defaultValue = "\"" + value + "\"";
			this.defaultValueFormatted = true;
			return this;
		}

		/**
		 * Format boolean as String for use as default value initializer.
		 * @param value the value to be formatted.
		 * @return FieldBuilder
		 */
		public FieldBuilder defaultValue(boolean value) {
			this.defaultValue = Boolean.toString(value);
			this.defaultValueFormatted = true;
			return this;
		}

		/**
		 * Take a Raw string value and pass through without manipulating for use as
		 * default value initializer.
		 * @param value the value to be formatted.
		 * @return FieldBuilder
		 */
		public FieldBuilder defaultValue(Raw value) {
			this.defaultValue = value.getValue();
			return this;
		}

		/**
		 * Format type as String.
		 * @param type the type to be formatted.
		 * @return this
		 */
		public FieldBuilder type(Class<?> type) {
			this.type = type.getName().toString();
			this.actualType = type;
			this.primitive = type.isPrimitive();
			return this;
		}

		/**
		 * Take a raw string value and pass through without manipulating for use as
		 * type.
		 * @param type the type
		 * @return
		 */
		public FieldBuilder type(Raw type) {
			this.type = type.getValue();
			return this;
		}

		/**
		 * Name builder for use in Deserialization.
		 * @param name
		 * @return builder
		 */
		@JsonAlias({"fieldName"})
		public FieldBuilder jsonName(String name) {
			return this.name(name);
		}

		/**
		 * Type builder for use in Deserialization.
		 *
		 * If the type is recognized, it is loaded and type(Class<?> type) is run.
		 * Also checks if the defaultValue needs to be escaped.
		 * @param type
		 * @return builder
		 */
		@JsonAlias({"fieldType"})
		public FieldBuilder jsonType(String type) {
			if (type == null) {
				return this;
			}
			Class<?> cls = getClassOrNull(type);
			if (cls == null) {
				cls = getClassOrNull("java.lang." + type);
			}
			if (cls == null) {
				this.type(raw(type));
			} else {
				this.type(cls);
			}
			if (shouldEscapeDefaultValue()) {
				this.defaultValue(defaultValue);
			}
			return this;
		}

		/**
		 * Default value builder for use in Deserialization.
		 *
		 * If type is already set as string, the value is wrapped in quotes. Otherwise,
		 * the value is passed through as is.
		 * @param defaultValue
		 * @return builder
		 */
		public FieldBuilder jsonDefaultValue(String defaultValue) {
			if (defaultValue == null) {
				return this;
			}
			this.defaultValue(raw(defaultValue));
			if (shouldEscapeDefaultValue()) {
				this.defaultValue(defaultValue);
			}
			return this;
		}

		/**
		 * Nullable builder for use in Deserialization.
		 * @param nullable
		 * @return builder
		 */
		public FieldBuilder jsonNullable(boolean nullable) {
			return this.nullable(nullable);
		}

		/**
		 * Primitive builder for use in Deserialization.
		 * @param primitive
		 * @return builder
		 */
		public FieldBuilder jsonPrimitive(boolean primitive) {
			return this.primitive(primitive);
		}

		/**
		 * Match builder for use in Deserialization.
		 *
		 * @param match
		 * @return builder
		 */
		public FieldBuilder jsonMatch(boolean match) {
			return this.match(match);
		}

		/**
		 * DocString builder for use in Deserialization.
		 * @param docString
		 * @return builder
		 */
		public FieldBuilder jsonDocString(String docString) {
			return this.docString(docString);
		}

		/**
		 * Getter builder for use in Deserialization.
		 * @param getter
		 * @return
		 */
		public FieldBuilder jsonGetter(boolean getter) {
			return this.getter(getter);
		}

		/**
		 * Setter builder for use in Deserialization.
		 * @param setter
		 * @return
		 */
		public FieldBuilder jsonSetter(boolean setter) {
			return this.setter(setter);
		}

		/**
		 * DefaultField builder for use in Deserialization.
		 * @param defaultField
		 * @return
		 */
		public FieldBuilder jsonDefaultField(boolean defaultField) {
			return this.defaultField(defaultField);
		}

		/**
		 * Search builder for use in Deserialization.
		 * @param search
		 * @return
		 */
		public FieldBuilder jsonSearch(boolean search) {
			return this.search(search);
		}
	}
}
