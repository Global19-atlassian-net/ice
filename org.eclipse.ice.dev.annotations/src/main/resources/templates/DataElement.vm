#if($package)
package $package;
#end

import java.io.Serializable;
import java.util.UUID;

import org.eclipse.ice.dev.annotations.IDataElement;
import org.eclipse.ice.dev.annotations.JavascriptValidator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;
import com.fasterxml.jackson.annotation.PropertyAccessor;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * This is an implementation of $interface that satisfies the dependencies of
 * the @DataElement Annotation and was auto-generated by the ICE Framework.
 */
@Data
@NoArgsConstructor
public class ${class} implements ${interface}, Serializable, IDataElement {

	/**
	 * Logging tool
	 */
	private static final Logger logger = LoggerFactory.getLogger(${class}.class);

	/**
	 * A unique private id that identifies the data element
	 */
	private UUID privateId = UUID.randomUUID();

	/**
	 * A simple name for the data
	 */
	private String name = "name";

	/**
	 * A simple description for the data
	 */
	private String description = "description";

	/**
	 * A unique identifier
	 */
	private Long id = 0L;

	/**
	 * A comment that annotates the data in meaningful way
	 */
	private String comment = "no comment";

	/**
	 * The context (a tag) in which the data should be considered
	 */
	private String context = "default";

	/**
	 * This value is true if the element should be regarded as a client as required.
	 */
	private boolean required;

	/**
	 * This value is true if the element should be regarded as a secret by a client,
	 * such as for passwords.
	 */
	private boolean secret;

	/**
	 * The validator used to check the correctness of the data
	 */
	private JavascriptValidator<${class}> validator;

	/**
	 * Generated from DataField annotations
	 */
	#foreach($field in $fields)
	protected ${field.ClassName} ${field.Name};
	#end

	public $class($class other) throws Exception {
		if (other == null) {
			throw (new Exception("$class to copy cannot be null."));
		}
		if (!(other instanceof $class)) {
			throw (new Exception("$class can copy only from other instances of $class."));
		}
		#foreach($prop in ["name", "description", "comment", "id", "context", "privateId", "validator", "secret", "required"])
		this.$prop = other.$prop;
		#end
		#foreach($field in $fields)
		this.${field.Name} = other.${field.Name};
		#end
	}

	/**
	 * This operation serializes the data element to a string in verified JSON.
	 * 
	 * @return a JSON string describing the element
	 */
	public String toJSON() {
		String value = null;
		// Convert to json using Jackson
		ObjectMapper mapper = new ObjectMapper();
		// Set visibility so that only methods are serialized. This removes duplication
		// otherwise produced due to the convenience methods.
		mapper.setVisibility(PropertyAccessor.FIELD, Visibility.ANY);
		mapper.setVisibility(PropertyAccessor.GETTER, Visibility.NONE);
		mapper.setVisibility(PropertyAccessor.IS_GETTER, Visibility.NONE);
		try {
			value = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(this);
		} catch (JsonProcessingException e) {
			logger.error("Unable to write DataElement to string!", e);
		}

		return value;
	}

	/**
	 * This operation deserializes a valid JSON string and tries to load it into the
	 * object.
	 * 
	 * @param jsonDataElement the contents of this data element as JSON
	 */
	public void fromJSON(final String jsonDataElement) {

		// Load the data from the string with Jackson.
		ObjectMapper mapper = new ObjectMapper();
		try {
			JsonNode rootNode = mapper.readTree(jsonDataElement);

			// Static Fields
			#foreach($prop in ["name", "description", "comment", "context"])
			// $prop
			JsonNode ${prop}Node = rootNode.get("$prop");
			$prop = mapper.treeToValue(${prop}Node, String.class);

			#end

			// id
			JsonNode idNode = rootNode.get("id");
			id = mapper.treeToValue(idNode, Long.class);

			// Required and secret booleans
			JsonNode requiredNode = rootNode.get("required");
			required = mapper.treeToValue(requiredNode, Boolean.class);
			JsonNode secretNode = rootNode.get("secret");
			secret = mapper.treeToValue(secretNode, Boolean.class);

			// Private ids
			JsonNode privateIdNode = rootNode.get("privateId");
			privateId = mapper.treeToValue(privateIdNode, UUID.class);

			// Validators
			JsonNode validatorNode = rootNode.get("validator");
			if (rootNode.hasNonNull("validator")) {
				validator = mapper.treeToValue(validatorNode, validator.getClass());
			} else {
				validator = null;
			}

			// Dynamic Fields
			#foreach($field in $fields)
			// ${field.Name}
			JsonNode ${field.Name}Node = rootNode.get("${field.Name}");
			${field.Name} = mapper.treeToValue(${field.Name}Node, ${field.ClassName}.class);

			#end
		} catch (JsonProcessingException e) {
			logger.error("Unable to read DataElement from string!", e);
		}

		return;
	}
}
