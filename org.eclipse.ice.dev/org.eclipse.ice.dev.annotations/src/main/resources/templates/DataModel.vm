#parse("templates/common.vm")
#if($package)
package $package;
#end

import java.io.Serializable;
import java.io.IOException;

import java.util.Collections;
import java.util.Map;
import java.util.HashMap;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.eclipse.ice.dev.annotations.IDataElement;

import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;
import com.fasterxml.jackson.annotation.PropertyAccessor;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

import lombok.AccessLevel;
import lombok.Data;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.NonNull;
import lombok.Setter;

/**
 * This is an implementation of $interface that satisfies the dependencies of
 * the @DataElement Annotation and was auto-generated by the ICE Framework.
 */
@Data
@NoArgsConstructor
public class ${class} implements ${interface}, Serializable {

	/**
	 * Logging tool
	 */
	private static final Logger logger = LoggerFactory.getLogger(${class}.class);
	#foreach($field in $fields)

		#fielddoc
		#nonnull($tab, $newline)
		#if(!${field.Getter})
	@Getter(AccessLevel.NONE)
		#end
		#if(!${field.Setter})
	@Setter(AccessLevel.NONE)
		#end
		#fielddecl
	#end
	#foreach($field in ${fields.Constants})

		#fielddoc
		#fielddecl
	#end
	#foreach($field in $fields)
		#foreach($alias in ${field.aliases})
			#if(${alias.Getter})

	/**
	 * Get ${field.Name} by alias ${alias.Name}.
	 * @return ${field.Name}
	 */
	public #fieldtype get${alias.NameForMethod}() {
		return ${field.Name};
	}
			#end
			#if(${alias.Setter})

	/**
	 * Set ${field.Name} by alias ${alias.Name}.
	 */
	public void set${alias.NameForMethod}(#nonnull #fieldtype ${field.Name}) {
		this.${field.Name} = ${field.Name};
	}
			#end
		#end
	#end
	
	#if($VelocityUtils.anyDataElementsExist($fields))
		#set($injectedFields ="")
		#set($separator="")
		#foreach($field in $VelocityUtils.collectAllDataElementFields($fields))
		#set($injectedFields  = $injectedFields  +$separator +$field.Type + " " + $field.Name)
		#set($separator = ", ")
		#end
	@Inject
	public ${class}(${injectedFields}){
		#foreach($field in $VelocityUtils.collectAllDataElementFields($fields))
		this.${field.Name} = $field.Name;
		#end
		}
	#end

	/**
	 * Copy constructor for $class.
	 * @param other Instance of $class to copy
	 * @throws Exception if other is null or not of type $class or other errors.
	 */
	public $class($class other) throws Exception {
		if (other == null) {
			throw (new Exception("$class to copy cannot be null."));
		}
		if (!(other instanceof $class)) {
			throw (new Exception("$class can copy only from other instances of $class."));
		}
		#foreach($field in $fields)
		this.${field.Name} = other.${field.Name};
		#end
	}

	/**
	 * This operation clones the object. Note that it differs from the base class
	 * implementation in that it will return null if it cannot create the clone to
	 * promote fast failure. See {@link java.lang.Object#clone()};
	 */
	@Override
	public Object clone() {
		try {
			// Call the copy constructor to create the clone.
			return new $class(this);
		} catch (Exception e) {
			logger.error("Unable to clone $class!", e);
			return null;
		}
	}

	/**
	 * This function checks deep equality of DataElements to see if all members are
	 * equal ("match") with the exception of fields with match set to false (such
	 * as an automatically generated UUID). This is important for checking if two
	 * objects were generated separately but are otherwise equal.
	 *
	 * @param o the other element to compare
	 * @return true if all members of the element except excluded fields match
	 *         this element.
	 */
	public boolean matches(Object o) {
		boolean retval = false;

		// Outer check for null comparisons
		if (o != null) {
			// Next check for shallow comparison
			if (this != o) {
				if (o instanceof $class) {
					$class other = ($class) o;

					// Separate boolean checks used to enable better catching
					// by debuggers.
					#foreach($field in ${fields.Match})

					boolean ${field.Name}Match =
					#if(${field.Nullable})
						this.${field.Name} == null ?
							this.${field.Name} == other.${field.Name} :
							this.${field.Name}.equals(other.${field.Name});
					#elseif(${field.Primitive})
						this.${field.Name} == other.${field.Name};
					#else
						this.${field.Name}.equals(other.${field.Name});
					#end## if nullable
					#else
					// Not checking ${field.Name}
					#end## foreach

					retval =
					#@settab(6)
						#foreach($field in ${fields.Match})#@nonewline
						${field.Name}Match#if($foreach.hasNext) &&#if($foreach.count % 3 == 0)$newline#else #end#else;$newline#end
						#end#end
					#end
				}
			} else {
				// This should be true if they are the same because the deep comparison is
				// performed otherwise.
				retval = true;
			}
		}
		return retval;
	}

	/**
	 * This operation serializes the data element to a string in verified JSON.
	 *
	 * @return a JSON string describing the element
	 */
	public String toJSON() {
		String value = null;
		// Convert to json using Jackson
		ObjectMapper mapper = new ObjectMapper();
		// Set visibility so that only methods are serialized. This removes duplication
		// otherwise produced due to the convenience methods.
		mapper.setVisibility(PropertyAccessor.FIELD, Visibility.ANY);
		mapper.setVisibility(PropertyAccessor.GETTER, Visibility.NONE);
		mapper.setVisibility(PropertyAccessor.IS_GETTER, Visibility.NONE);
		try {
			value = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(this);
		} catch (JsonProcessingException e) {
			logger.error("Unable to write DataElement to string!", e);
		}

		return value;
	}

	/**
	 * Load DataElement from JsonNode.
	 * @param rootNode DataElement root as JsonNode
	 * @param mapper ObjectMapper to convert values
	 */
	private void fromJsonNode(final JsonNode rootNode, final ObjectMapper mapper) throws JsonProcessingException {
		#foreach($field in $fields)
		// ${field.Name}
		JsonNode ${field.Name}Node = rootNode.get("${field.Name}");
		#if(${field.Nullable})
		if (rootNode.hasNonNull("${field.Name}")) {
			${field.Name} = mapper.treeToValue(${field.Name}Node, ${field.Name}.getClass());
		} else {
			${field.Name} = null;
		}
		#elseif($field.Type.toString().contains("<"))
		try {
			${field.Name} = mapper.readValue(mapper.treeAsTokens(${field.Name}Node), new TypeReference<${field.Type}>() { });
		} catch (IOException e){
			e.printStackTrace();
		}
		#else
		${field.Name} = mapper.treeToValue(${field.Name}Node, ${field.Type}.class);
		#end

		#end
	}

	/**
	 * This operation deserializes a valid JSON string and tries to load it into the
	 * object.
	 *
	 * @param jsonDataElement the contents of this data element as JSON
	 */
	public $interface fromJSON(final String jsonDataElement) {

		// Load the data from the string with Jackson.
		ObjectMapper mapper = new ObjectMapper();
		try {
			JsonNode rootNode = mapper.readTree(jsonDataElement);
			fromJsonNode(rootNode, mapper);
		} catch (JsonProcessingException e) {
			logger.error("Unable to read DataElement from string!", e);
		}

		return this;
	}

	/**
	 * Load from a String-Object Map, skipping the String parsing step. Structures
	 * such as <code>org.bson.Document</code> implement Map<String, Object> and
	 * therefore do not need to be processed from raw String form.
	 *
	 * @param jsonDataElement the contents of this data element as a Map<String, Object>
	 */
	public <T extends Map<String, Object>> $interface fromJSON(final T jsonDataElement) {

		// Load the data from the string with Jackson.
		ObjectMapper mapper = new ObjectMapper();
		try {
			JsonNode rootNode = mapper.valueToTree(jsonDataElement);
			fromJsonNode(rootNode, mapper);
		} catch (JsonProcessingException e) {
			logger.error("Unable to read DataElement from string!", e);
		}

		return this;
	}
	
	enum IDataElementTypes {
		#foreach($field in $fields)
		#if($VelocityUtils.isIDataElementOrCollectionOf($field.Mirror))
		#set($classname = $VelocityUtils.getCollectionParameterType($field.Mirror).toString())
		${field.Name}Type(${classname}.class.toString()),
		#end
		#end
		None("None");
		
		private final String name;       

	    private IDataElementTypes(String s) {
	        name = s;
	    }
	
	    public boolean equalsName(String otherName) {
	        return name.equals(otherName);
	    }
	
	    public String toString() {
	       return this.name;
	    }
		
	}
	
	@Override
	public boolean add(IDataElement dataElement) {
		// TODO Auto-generated method stub
		final String elementClass = dataElement.getClass().toString();
		switch(IDataElementTypes.valueOf(elementClass)){
		#foreach($field in $fields)
		#if($VelocityUtils.isIDataElementOrCollectionOf($field.Mirror))
		#set($classname = $VelocityUtils.getCollectionParameterType($field.Mirror).toString())
			case ${field.Name}Type:
			return ${field.Name}.add((${classname})dataElement);	
		#elseif($field.Mirror)
		#set($generic = $VelocityUtils.getCollectionParameterType($field.Mirror))
		$VelocityUtils.isIDataElement($VelocityUtils.getCollectionParameterType($field.Mirror)))
		#end
		#end
		default:
		return false;
		}
	}

	@Override
	public void add(int index, IDataElement dataElement) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public boolean addAll(Collection<? extends IDataElement> dataElementCollection) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean addAll(int index, Collection<? extends IDataElement> dataElementCollection) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public void clear() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public boolean contains(Object dataElement) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean containsAll(Collection<?> collection) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public IDataElement get(int index) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public int indexOf(Object dataElement) {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public boolean isEmpty() {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public Iterator<IDataElement> iterator() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public int lastIndexOf(Object dataElement) {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public ListIterator<IDataElement> listIterator() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public ListIterator<IDataElement> listIterator(int index) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public boolean remove(Object dataElement) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public IDataElement remove(int index) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public boolean removeAll(Collection<?> dataElementCollection) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean retainAll(Collection<?> dataElementCollection) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public IDataElement set(int index, IDataElement dataElement) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public int size() {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public List<IDataElement> subList(int start, int end) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object[] toArray() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public <T> T[] toArray(T[] arg0) {
		// TODO Auto-generated method stub
		return null;
	}
}