#if($package)
package $package;
#end

import java.io.Serializable;
import java.util.UUID;

import org.eclipse.ice.dev.annotations.IDataElement;
import org.eclipse.ice.dev.annotations.JavascriptValidator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;
import com.fasterxml.jackson.annotation.PropertyAccessor;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.NonNull;

/**
 * This is an implementation of $interface that satisfies the dependencies of
 * the @DataElement Annotation and was auto-generated by the ICE Framework.
 */
@Data
@NoArgsConstructor
public class ${class} implements ${interface}, Serializable, IDataElement {

	/**
	 * Logging tool
	 */
	private static final Logger logger = LoggerFactory.getLogger(${class}.class);

	#foreach($field in $fields)

	#if(${field.Comment})
	/**
	 * ${field.Comment}
	 */
	#end
#if(!${field.Nullable} && !${field.Primitive})	@NonNull #else	#{end}protected #evaluate(${field.Type}) ${field.Name}#if(${field.DefaultValue}) = #evaluate(${field.DefaultValue})#end;
	#end

	/**
	 * Copy constructor for $class.
	 * @param other Instance of $class to copy
	 * @throws Exception if other is null or not of type $class or other errors.
	 */
	public $class($class other) throws Exception {
		if (other == null) {
			throw (new Exception("$class to copy cannot be null."));
		}
		if (!(other instanceof $class)) {
			throw (new Exception("$class can copy only from other instances of $class."));
		}
		#foreach($field in $fields)
		this.${field.Name} = other.${field.Name};
		#end
	}

	/**
	 * This operation clones the object. Note that it differs from the base class
	 * implementation in that it will return null if it cannot create the clone to
	 * promote fast failure. See {@link java.lang.Object#clone()};
	 */
	@Override
	public Object clone() {
		try {
			// Call the copy constructor to create the clone.
			return new $class(this);
		} catch (Exception e) {
			logger.error("Unable to clone $class!", e);
			return null;
		}
	}

	/**
	 * This function checks deep equality of DataElements to see if all members are
	 * equal ("match") with the exception of fields with match set to false (such
	 * as an automatically generated UUID). This is important for checking if two
	 * objects were generated separately but are otherwise equal.
	 *
	 * @param o the other element to compare
	 * @return true if all members of the element except excluded fields match
	 *         this element.
	 */
	public boolean matches(Object o) {
		if (o == this) return true;
		if (!(o instanceof $class)) return false;
		$class other = ($class) o;
		#foreach($field in $fields)
		#if(${field.Match})
		#if(${field.Nullable})
		if (this.${field.Name} != null) {
			if (!this.${field.Name}.equals(other.${field.Name})) return false;
		} else {
			if (this.${field.Name} != other.${field.Name}) return false;
		}
		#elseif(${field.Primitive})
		if (this.${field.Name} != other.${field.Name}) return false;
		#else
		if (!this.${field.Name}.equals(other.${field.Name})) return false;
		#end## if nullable
		#else
		// Not checking ${field.Name}
		#end## if match
		#end## foreach

		return true;
	}

	/**
	 * This operation serializes the data element to a string in verified JSON.
	 *
	 * @return a JSON string describing the element
	 */
	public String toJSON() {
		String value = null;
		// Convert to json using Jackson
		ObjectMapper mapper = new ObjectMapper();
		// Set visibility so that only methods are serialized. This removes duplication
		// otherwise produced due to the convenience methods.
		mapper.setVisibility(PropertyAccessor.FIELD, Visibility.ANY);
		mapper.setVisibility(PropertyAccessor.GETTER, Visibility.NONE);
		mapper.setVisibility(PropertyAccessor.IS_GETTER, Visibility.NONE);
		try {
			value = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(this);
		} catch (JsonProcessingException e) {
			logger.error("Unable to write DataElement to string!", e);
		}

		return value;
	}

	/**
	 * This operation deserializes a valid JSON string and tries to load it into the
	 * object.
	 *
	 * @param jsonDataElement the contents of this data element as JSON
	 */
	public void fromJSON(final String jsonDataElement) {

		// Load the data from the string with Jackson.
		ObjectMapper mapper = new ObjectMapper();
		try {
			JsonNode rootNode = mapper.readTree(jsonDataElement);

			#foreach($field in $fields)
			// ${field.Name}
			JsonNode ${field.Name}Node = rootNode.get("${field.Name}");
			#if(${field.Nullable})
			if (rootNode.hasNonNull("${field.Name}")) {
				${field.Name} = mapper.treeToValue(${field.Name}Node, ${field.Name}.getClass());
			} else {
				${field.Name} = null;
			}
			#else
			${field.Name} = mapper.treeToValue(${field.Name}Node, ${field.Type}.class);
			#end

			#end
		} catch (JsonProcessingException e) {
			logger.error("Unable to read DataElement from string!", e);
		}

		return;
	}
}
